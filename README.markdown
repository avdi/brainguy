# Brainguy

![Observer, AKA "Brain Guy"](http://static.tvtropes.org/pmwiki/pub/images/MST3K_Brain_Guy_7093.jpg)

Brainguy is an Observer library for Ruby.

## Synopsis

```ruby
require "brainguy"

class SatelliteOfLove
  include Brainguy::Observable

  def intro_song
    emit(:robot_roll_call)
  end

  def send_the_movie
    emit(:movie_sign)
  end
end

class Crew
  include Brainguy::Observer
end

class TomServo < Crew
  def on_robot_roll_call(event)
    puts "Tom: Check me out!"
  end
end

class CrowTRobot < Crew
  def on_robot_roll_call(event)
    puts "Crow: I'm different!"
  end
end

class MikeNelson < Crew
  def on_movie_sign(event)
    puts "Mike: Oh no we've got movie sign!"
  end
end

sol = SatelliteOfLove.new
# Attach specific event handlers without a listener object
sol.on(:robot_roll_call) do
  puts "[Robot roll call!]"
end
sol.on(:movie_sign) do
  puts "[Movie sign flashes]"
end
sol.events.attach TomServo.new
sol.events.attach CrowTRobot.new
sol.events.attach MikeNelson.new

sol.intro_song
sol.send_the_movie

# >> [Robot roll call!]
# >> Tom: Check me out!
# >> Crow: I'm different!
# >> [Movie sign flashes]
# >> Mike: Oh no we've got movie sign!

```

## Introduction

*Well, here we are again.*

Back with another of those block-rockin' READMEs!

*You know, I can just leave now.*

Sorry. It won't happen again.

*So, "Brainguy", huh. What's the deal this time?*

This is an Observer pattern library for Ruby. The name is a play on the
character from Mystery Sci---

*Yeah yeah blah blah nerd nerd very clever. What's it do?*

In a nutshell, it's a decoupling mechanism. It lets "observer" objects
subscribe to events generated by other objects.

*Kind of like the `observer` Ruby standard library?"*

Yeah, exactly. But this library is a little bit fancier. It adds a
number of conveniences that you otherwise might have to build yourself on top of `observer`.

*Such as?*

Well, the most important feature it has is *named event types*. Instead of a single "update" event, events have symbolic names. Observers can choose which events they care about, and ignore the rest.

*What exactly is a "observer"? Is it a special kind of object?*

Not really, no. Fundamentally a observer is any object which responds to `#call`. The most obvious example of such an object is a `Proc`. Here's an example of using a proc as a simple observer:

```ruby
require "brainguy"

events = Brainguy::Emitter.new
observer = proc do |event|
  puts "Got event: #{event.name}"
end
events.attach(observer)
events.emit(:ding)

# >> Got event: ding

```

Every time the emitter emits an event, the observer proc will receive `#call` with an `Event` object as an argument.

*What's an "emitter"?*

An Emitter serves dual roles: first, it manages subscriptions to a particular event source. And second, it can "emit" events to all of the observers currently subscribed to it.

*What exactly is an "event", anyway?*

Notionally an event is some occurrence in an object, which other objects might want to know about. What sort of occurrences might be depends on your problem domain. A `User` might have a `:modified` event. An `WebServiceRequest` might have a `:success` event. A `Toaster` might have a `:pop` event. And so on.

*So an event is just a symbol?*

An event is *named* with a symbol. But there is some other information that normally travels along with an event:

- An event *source*, which is the observer object that generated the event.
- An arbitrary list of *arguments*.

Extra arguments can be added to an event by passing extra arguments to the `#emit`, like this:

```ruby
events.emit(:movie_sign, movie_title: "Giant Spider Invasion"
```

For convenience, the event name, source, and arguments are all bundled into an `Event` object before being disseminated to observers.

*OK, say I have an object that I want to make observable. How would I go about that?*

Well, the no-magic way might go something like this:

```ruby
require "brainguy"

class Toaster
  attr_reader :events

  def initialize
    @events = Brainguy::Emitter.new(self)
  end

  def make_toast
    events.emit(:start)
    events.emit(:pop)
  end
end

toaster = Toaster.new
toaster.events.on(:pop) do
  puts "Toanst is done!"
end
toaster.make_toast

# >> Toast is done!

```

Notice that we pass `self` to the new `Emitter`, so that it will know what object to set as the event source for emitted events.

*That's pretty straightforward. Is there a more-magic way?*

Of course! But it's not much more magic. There's an `Observable` module that just packages up the convention we used above into a reusable mixin you can use in any of your classes. Here's what that code would look like using the mixin:

```ruby
require "brainguy"

class Toaster
  include Brainguy::Observable

  def make_toast
    emit(:start)
    emit(:pop)
  end
end

toaster = Toaster.new
toaster.on(:pop) do
  puts "Toast is done!"
end
toaster.make_toast

# >> Toast is done!

```

*I see that instead of `events.emit(...)`, now the class just uses `emit(...)`. And the same with `#on`.*

Very observant! `Observable` adds three methods to classes which mix it in:

- `#on`, to quickly attach single-event handlers on the object.
- `#emit`, a private method for conveniently emitting events inside the class.
- `#events`, to access the `Emitter` object.

*That's not a lot of methods added.*

Nope! That's intentional. These are your classes, and I don't want to clutter up your API unnecessarily. `#on` and `#emit` are provided as conveniences for common actions. Anything else you need, you can get to via the `Emitter` returned from `#events`.

*I see that un-handled events are just ignored. Doesn't that make it easy to miss events because of a typo in the name?*

Yeah, it kinda does. In order to help with that, there's an alternative kind of emitter: a `ManifestEmitter`. And to go along with it, there's a `ManifestlyObservable` mixin module. We customize the module with a list of known event names. Then if anything tries to either emit or subscribe to an unknown event name, the emitter outputs a warning.

Well, that's what it does by default. We can also customize the policy for how to handle unknown events, as this example demonstrates:

```ruby
require "brainguy"

class Toaster
  include Brainguy::ManifestlyObservable.new(:start, :pop)

  def make_toast
    emit(:start)
    emit(:lop)
  end
end

toaster = Toaster.new
toaster.events.unknown_event_policy = :raise_error
toaster.on(:plop) do
  puts "Toast is done!"
end
toaster.make_toast

# ~> Brainguy::UnknownEvent
# ~> #on received for unknown event type 'plop'
# ~>
# ~> xmptmp-in27856uxq.rb:14:in `<main>'

```

*I'm still a little confused about `#on`. Is that just another way to add an observer?*

`#on` is really just a shortcut. Often we don't want to attach a whole observer to an observable object. We just want to trigger a particular block of code to be run when a specific event is detected. So `#on` makes it easy to hook up a block of code to a single event.

*So it's a special case.*

Yep!

*Let's talk about the general case a bit more. You said an observer is just a callable object?*

Yeah. Anything which will respond to `#call` and accept a single `Event` as an argument.

*But what if I want my observer to do different things depending on what kind of event it receives? Do I have to write a case statement inside my `#call` method?*

You could if you wanted to. But that's a common desire, so there are some conveniences for it.

*Such as...?*

Well, first off, there's `OpenObserver`. It's kinda like Ruby's `OpenObject`, but for observer objects. You can use it to quickly put together a reusable observer object. For instance, here's an example where we have two different observable objects, observed by a single `OpenObserver`.

```ruby
require "brainguy"

class VideoRender
  include Brainguy::Observable
  attr_reader :name
  def initialize(name)
    @name = name
  end
  
  def do_render
    emit(:complete)
  end
end

v1 = VideoRender.new("foo.mp4")
v2 = VideoRender.new("bar.mp4")

observer = Brainguy::OpenObserver.new do |o|
  o.on_complete do |event|
    puts "Video #{event.source.name} is done rendering!"
  end
end

v1.events.attach(observer)
v2.events.attach(observer)

v1.do_render
v2.do_render

# >> Video foo.mp4 is done rendering!
# >> Video bar.mp4 is done rendering!

```

There are a few other ways to instantiate an `OpenObserver`; check out the source code and tests for more information.

*What if my observer needs are more elaborate? What if I want a dedicated class for observing an event stream?*

There's a helper for that as well. Here's an example where we have a `Poem` class that can recite a poem, generating events along the way. And then we have an `HtmlFormatter` which observes those events and incrementally constructs some HTML text as it does so.

```ruby
require "brainguy"

class Poem
  include Brainguy::Observable
  def recite
    emit(:title, "Jabberwocky")
    emit(:line, "'twas brillig, and the slithy toves")
    emit(:line, "Did gyre and gimbal in the wabe")
  end
end

class HtmlFormatter
  include Brainguy::Observer

  attr_reader :result
  
  def initialize
    @result = ""
  end
  
  def on_title(event)
    @result << "<h1>#{event.args.first}</h1>"
  end

  def on_line(event)
    @result << "#{event.args.first}</br>"
  end
end

p = Poem.new
f = HtmlFormatter.new
p.events.attach(f)
p.recite

f.result
# => "<h1>Jabberwocky</h1>'twas brillig, and the slithy toves</br>Did gyre an...

```

*So including `Observer` automatically handles the dispatching of events from `#call` to the various `#on_*` methods?*

Yes, exactly. And through some metaprogramming, it is able to do this in a way that is just as performant as a hand-written case statement.

*How do you know it's that fast?*

You can run the proof-of-concept benchmark for yourself! It's in the `scripts` directory.

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'brainguy'
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install brainguy

## Usage

Coming soon!

## Contributing

1. Fork it ( https://github.com/[my-github-username]/brainguy/fork )
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request
